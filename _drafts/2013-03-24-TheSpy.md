---
layout: post
title: The Spy 
---

# The Spy Challenge 
* * * 

## Introduction: 

The hackfortress challenge was part of the Schmoocon challenge a few years ago and while I attempted 
them at the time I never fully documented them or completed all of them. So in the next few posts I 
will explain how to complete each of the challenges. The first of the challenges is the spy challenge.

## Getting Started

I will try to complete all the challenges using a unix OS. As such for the most part , most of the tools
that will be used will be command line tools. If its also not completely obvious from my selection of 
command line tools , the aim of this and future posts is to learn assembly and reversing by applying
yourself. The outcome should be an understanding of how things work and an understand of how and why
things were taken appart.

Note I will be performing all the compilations etc on a x64 machine as such the registers may differ to
what you encounter if you work along with this article.

### Grabbing the challenges :

To start of run the following code to checkout the code to a local folder.

	git clone git://github.com/peasleer/hackfortress.git

After having checked out all the code its time to tackle the first challenge. To do that run the
following commands which will put you into the spy folder.

	cd hackfortressa/spy

	make
	
Note : While the C code is available , this is a reversing challenge so dont look at the code till
you have attempted to finish the challenge.

After building the project we should have the following file listing : 

-rw-r--r-- 1 rc1140 rc1140 1.3K Mar 24 13:21 spy.c
-rw-r--r-- 1 rc1140 rc1140  197 Mar 24 13:21 README
-rw-r--r-- 1 rc1140 rc1140   68 Mar 24 13:21 Makefile
-rwxrwxr-x 1 rc1140 rc1140 5.5K Mar 25 13:10 spy

At this point we can run the binary to see what happens and the following bits of info will be printed
to the console.

	[ H A C K | F O R T R E S S ]
	We've intercepted a secret message, but can't decrypt it. 
	If you provide us with the right key, we'll help your team!

This is the same information that is provided in the README file that come along with the project.As 
such it doesnt give us much more information. The Readme on the other hand further explains that we need to provide
a md5 hash of the message to complete the challenge.

At this point the question is what message are they asking for us to md5. So a simple test is
to try and provide a commandline arg to see what happens.

	./spy hello

Running the command above gives us the following output 

	8
	If the result looks right, MD5 your result and submit it:
	QZM\A^VL_XQRQVQFQSPS\OLSZ\Q\Y^VVVYMã

So with this output we at least know what message needs hashing we also have a another
string message that we can use while tracing ("If the result looks right, MD5 your result and submit it:").
Finally without looking at the code I am not sure what the 8 is , its not the length of my
key but it does change when I change to different keys. Finally the cipher algoratharim is likely to 
be pretty simple since the same key always generates the same output.

### String Extraction : 

Now that we have a basic idea of whats going with the app ,its always good to get a dump 
of all the strings that are in use in the binary. This will allow us to spot
patterns and possibly locations that need to be investigated before
we even get to debugging the binary. Add to the fact that we have specific strings being
printed for the final message we can use these strings to make tracing even easier. 
To get a dump of all the strings in a binary run the following command

	strings spy > spyStrings.txt

Aside from extracting the strings this also saves the strings to a file for future reference.

If we now look at the strings that were dumped , we can see all the messages we came across
and what looks like a bunch of random data conveniently stored in X byte chunks. This is more
likely than not the cipher text and setting a break point on this would probably be a quick
way to get to the key we want.

Next before jumping into debugging the binary its good to a listing of the application to 
read through. This will give us a roadmap on how the binary should work before we start
debugging the application. It will also allow us to read through the code and perform offline
analysis about how the application works.To get a disassembly listing of the binary run the follwing 
command.

	objdump -D -S -f spy > spyDump.txt

The next thing to do is to get the entry pointt for the application. Thankfully this is fairly
easy , if you have been following till now we can get this easily from the spyDump.txt. Simply
open the file and go to line 5 which should contain the following line (note your exact address
will be different).

	start address 0x400580

Voila we now know the entry point of the application which in my case could have been 0x400580.
If we so wanted we could start reading through the spyDumpt.txt file from that location to 
determine what the application is doing when it starts running.

But before we get there is also useful to know the the how many functions we are dealing with in
the application. To do this we can cheat a bit by making a couple assumptions. First by assuming 
that the authors of the challenge meant it to be a beginners challenge they wouldnt have changed 
the function call type to anything other than cdecl. Now with the cdecl call type the stack
needs to be wound at the begining at a function before the stack can be used. With this in mind
I wrote a very small parser application to extract the text section from the dump and extract
each of the lines of code that wind the stack. Once we have extracted this we know the memory
locations of each of the functions and can use them by adding breakpoints at these locations
when debugging.

To get the function start locations run the script :
	
	python parse.py > functionhandles.txt

Now that we have the approximate entry points for each of the functions used in the app its 
time to do some quick mental mapping of when the calls should happen.

With our function handles stored and our entry point recorded its time to start digging into
some of the code. Start of my loading the spyDump.txt into your favorite text editor of choice.

Once the file is loaded search for the entry point address that we found earlier (0x400580) with
out the 0x at the start. This should land you at the following chunk of code (there is alot more
I have just snipped it to be more readable).

	400580:	31 ed                	xor    %ebp,%ebp
	400582:	49 89 d1             	mov    %rdx,%r9
	400585:	5e                   	pop    %rsi
	400586:	48 89 e2             	mov    %rsp,%rdx
	400589:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
	40058d:	50                   	push   %rax
	40058e:	54                   	push   %rsp
	40058f:	49 c7 c0 90 09 40 00 	mov    $0x400990,%r8
	400596:	48 c7 c1 20 09 40 00 	mov    $0x400920,%rcx
	40059d:	48 c7 c7 70 06 40 00 	mov    $0x400670,%rdi
	4005a4:	e8 97 ff ff ff       	callq  400540 <__libc_start_main@plt>

This little bit of assembly is what sets up the argv,argc etc for the function which is about to be called
and then fires of a call to the __libc_start_main. This little bit of setup code is important to us because
we will be passing in our key via argv and as such we should keep this in mind while tracing the application.
Keep in mind that the location that we want to be 
navigating to next is the last value being setup on the stack for the main function which is printed below.

	40059d:	48 c7 c7 70 06 40 00 	mov    $0x400670,%rdi

The address passed to %rdi ($0x400670) is where the start function will return to after the call. Thus we need
to start reading the code from this location onwards. If you copy the
address that we will be looking at next and search of it in the functionsHandles text file that we created
earlier you will notice that it is the second function in the list of 4 used by the application. This means
that our little scraper tool worked and that we can use the rest of the handles as method for double checking
that we have analyzed all the functions in the application once we are complete.

So starting to dig into the code we can start at the address 400675:

400675:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp				;Reserve 152 bytes on the stack.
40067c:	89 bd 6c ff ff ff    	mov    %edi,-0x94(%rbp)			;Move edi into the first part of the reserved stack
400682:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)			;Move rsi into the second part of the reserved stack
400689:	83 bd 6c ff ff ff 01 	cmpl   $0x1,-0x94(%rbp)

Simply put this instruction reserves 152 bytes on the stack for use later as seen below. Once the data is reserved
we then move data from edi and rsi onto the stack

Step 1  reserve stack :
Reserving space on the stack causes the stack to grow downwards and subseuently moves the base pointer down.

[ESP		]
|152 bytes	|
[EBP		]

Summary of tools used :
	git
	gdb
		Setting Up GDB : 
			GDB is awesome but it  easy to miss the  coolness when working with assembly. THis section will 
			go over some of the basics that will make working through the article a bit easier.
			Firstly edit your ~/.gdbinit file and add the following lines:
				layout asm
				layout regs

			This will make the gdb ui a bit easier to work with when looking at assembly. Next when starting
			gdb use the following command and if possible try not to do this within a terminal multiplexer (tmux , screen)
			as it tends to make things look a little screwy. If at any point the interface does go a bit weird type the
			command 'refresh' to redraw the UI. Finally the command to use when starting gdb is to simply use the -tui
			param like this 'gdb -tui spy' when working with the spy application.

			Dynamic patching , see the exmaple from the stackoverflow site explaining things.
	objdump
	make
